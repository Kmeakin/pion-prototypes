use pion_lexer::token::TokenKind;
use pion_utils::location::BytePos;

use crate::event::{Event, EventsExt};
use crate::reporting::SyntaxError;
use crate::syntax::NodeKind::*;

grammar(
    events: &mut Vec<Event>,
    errors: &mut Vec<SyntaxError>,
);

extern {
    type Location = BytePos;
    type Error = std::convert::Infallible;

    enum TokenKind {
        "Ident" => TokenKind::Ident,
        "DecInt" => TokenKind::DecInt,
        "BinInt" => TokenKind::BinInt,
        "HexInt" => TokenKind::HexInt,

        "def" => TokenKind::KwDef,
        "else" => TokenKind::KwElse,
        "false" => TokenKind::KwFalse,
        "fun" => TokenKind::KwFun,
        "if" => TokenKind::KwIf,
        "let" => TokenKind::KwLet,
        "match" => TokenKind::KwMatch,
        "then" => TokenKind::KwThen,
        "true" => TokenKind::KwTrue,

        "(" => TokenKind::LParen,
        ")" => TokenKind::RParen,
        "{" => TokenKind::LCurly,
        "}" => TokenKind::RCurly,
        "[" => TokenKind::LSquare,
        "]" => TokenKind::RSquare,
        "_" => TokenKind::Underscore,
        "," => TokenKind::Comma,
        ";" => TokenKind::Semicolon,
        ":" => TokenKind::Colon,
        "." => TokenKind::Dot,
        "@" => TokenKind::At,
        "=" => TokenKind::Eq,
        "->" => TokenKind::ThinArrow,
        "=>" => TokenKind::FatArrow,
        "|" => TokenKind::Pipe,
    }
}

Token<T>: () = {
    <T> => events.token(<>),
}

StartNode: usize = {
    () => events.start_node(),
}

Lit: () = {
    <start: StartNode> Token<"true"> => events.end_node(start, BoolLit),
    <start: StartNode> Token<"false"> => events.end_node(start, BoolLit),
    <start: StartNode> Token<"DecInt"> => events.end_node(start, IntLit),
    <start: StartNode> Token<"BinInt"> => events.end_node(start, IntLit),
    <start: StartNode> Token<"HexInt"> => events.end_node(start, IntLit),
}

pub Module: () = {
    <start: StartNode> Item* => events.end_node(start, Module),
}

Item: () = {
    <error: !> => errors.push(SyntaxError::from_recovery(error)),
    Def => <>,
}

Def: () = {
    <start: StartNode> Token<"def"> Token<"Ident"> TypeAnn? Token<"="> Expr Token<";"> => events.end_node(start, DefItem),
}

pub Expr: () = {
    LetExpr => <>,
}

LetExpr: () = {
    <start: StartNode> Token<"let"> Pat TypeAnn? LetInit Token<";"> Expr => events.end_node(start, LetExpr),
    <start: StartNode> Token<"if"> Expr ThenExpr ElseExpr => events.end_node(start, IfExpr),
    FunExpr => <>,
}
LetInit: () = {
    <start: StartNode> Token<"="> Expr => events.end_node(start, LetInit),
}
ThenExpr: () = {
    <start: StartNode> Token<"then"> Expr => events.end_node(start, ThenExpr),
}
ElseExpr: () = {
    <start: StartNode> Token<"else"> Expr => events.end_node(start, ElseExpr),
}

FunExpr: () = {
    <start: StartNode> Token<"fun"> ParamList Token<"=>"> Expr => events.end_node(start, FunLitExpr),
    <start: StartNode> Token<"fun"> ParamList Token<"->"> Expr => events.end_node(start, FunTypeExpr),
    ArrowExpr => <>,
}
ParamList: () = {
    <start: StartNode> Token<"("> Sep0<FunParam, Token<",">> Token<")"> => events.end_node(start, FunParamList),
}
FunParam: () = {
    <start: StartNode> Token<"@">? Pat TypeAnn? => events.end_node(start, FunParam),
}
TypeAnn: () = {
    <start: StartNode> Token<":"> Expr => events.end_node(start, TypeAnn),
}

ArrowExpr: () = {
    <start: FieldProjExpr> RetType => events.wrap_node(start, FunArrowExpr),
    FieldProjExpr => {},
}
RetType: () = {
    <start: StartNode> Token<"->"> Expr => events.end_node(start, RetType),
}

FieldProjExpr: usize = {
    <start: FieldProjExpr> FieldProj => { events.wrap_node(start, FieldProjExpr); start },
    CallExpr => <>,
}
FieldProj: () = {
    Token<"."> Token<"Ident"> => {}
}

CallExpr: usize = {
    <start: CallExpr> ArgList => { events.wrap_node(start, FunCallExpr); start },
    <start: FieldProjExpr> FieldProj ArgList => { events.wrap_node(start, MethodCallExpr); start },
    AtomExpr => <>,
}
ArgList: () = {
    <start: StartNode> Token<"("> Sep0<FunArg, Token<",">> Token<")"> => events.end_node(start, FunArgList),
}
FunArg: () = {
    <start: StartNode> Token<"@">? Expr => events.end_node(start, FunArg),
}

AtomExpr: usize = {
    <start: StartNode> <error: !> => {
        events.error_node(start, &error);
        errors.push(SyntaxError::from_recovery(error));
        start
    },
    <start: StartNode> Lit => { events.end_node(start, LitExpr); start },
    <start: StartNode> Token<"_"> => { events.end_node(start, UnderscoreExpr); start },
    <start: StartNode> Token<"Ident"> => { events.end_node(start, IdentExpr); start } ,

    <start: StartNode> Token<"("> Expr TypeAnn Token<")"> => { events.end_node(start, AnnExpr); start },
    <start: StartNode> Token<"("> Expr Token<")"> => { events.end_node(start, ParenExpr); start },
    <start: StartNode> Token<"("> TupleSep<Expr, Token<",">> Token<")">  => { events.end_node(start, TupleLitExpr); start },

    <start: StartNode> Token<"["> Sep0<Expr, Token<",">>  Token<"]"> => { events.end_node(start, ArrayLitExpr); start },

    <start: StartNode> Token<"match"> Expr Token<"{"> Sep0<MatchCase,Token<",">> Token<"}"> => { events.end_node(start, MatchExpr); start },

    <start: StartNode> Token<"{"> Token<",">* Token<"}"> => { events.end_node(start, UnitRecordExpr); start },
    <start: StartNode> Token<"{"> Sep1<RecordExprField, Token<",">> Token<"}"> => { events.end_node(start, RecordLitExpr); start },
    <start: StartNode> Token<"{"> Sep1<RecordTypeField, Token<",">> Token<"}"> => { events.end_node(start, RecordTypeExpr); start },
}

RecordExprField: () = {
    <start: StartNode> Token<"Ident"> => events.end_node(start, RecordExprField),
    <start: StartNode> Token<"Ident"> Token<"="> Expr => events.end_node(start, RecordExprField),
}

RecordTypeField: () = {
    <start: StartNode> Token<"Ident"> Token<":"> Expr => events.end_node(start, RecordTypeField),
}

MatchCase: () = {
    <start: StartNode> Pat MatchGuard? Token<"=>"> Expr => events.end_node(start, MatchCase),
}

MatchGuard: () = {
    <start: StartNode> Token<"if"> Expr => events.end_node(start, MatchGuard),
}


pub Pat: () = {
    <start: AtomPat> Seq1<(Token<"|"> AtomPat)> => events.wrap_node(start, OrPat),
    AtomPat => {},
}

AtomPat: usize = {
    <start: StartNode> <error: !> => {
        events.error_node(start, &error);
        errors.push(SyntaxError::from_recovery(error));
        start
    },
    <start: StartNode> Lit => { events.end_node(start, LitPat); start },
    <start: StartNode> Token<"_"> => { events.end_node(start, UnderscorePat); start },
    <start: StartNode> Token<"Ident"> => { events.end_node(start, IdentPat); start },

    <start: StartNode> Token<"("> Pat Token<")"> => { events.end_node(start, ParenPat); start },
    <start: StartNode> Token<"("> TupleSep<Pat, Token<",">> Token<")"> => { events.end_node(start, TupleLitPat); start },

    <start: StartNode> Token<"{"> Sep0<RecordPatField, Token<",">> Token<"}"> => { events.end_node(start, RecordLitPat); start },
}

RecordPatField: () = {
    <start: StartNode> Token<"Ident"> => events.end_node(start, RecordPatField),
    <start: StartNode> Token<"Ident"> Token<"="> Pat => events.end_node(start, RecordPatField),
}

Seq0<Elem>: () = {
    () => {},
    Elem Seq0<Elem> => {},
}

Seq1<Elem>: () = {
    Elem Seq0<Elem> => {},
}

Seq2<Elem>: () = {
    Elem Seq1<Elem> => {},
}

Sep0<Elem, Sep>: () = {
    Sep* => {},
    Sep* (Elem Sep+)* Elem Sep* => {},
}

Sep1<Elem, Sep>: () = {
    Sep* (Elem Sep+)* Elem Sep* => {},
}

TupleSep<Elem, Sep>: () = {
    Sep* => {},
    Elem Sep+ => {},
    Sep+ Elem => {},
    Sep+ Elem Sep+ => {},
    Sep* (Elem Sep+)+ Elem Sep* => {},
}
