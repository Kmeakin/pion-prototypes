use pion_manual_lexer::token::TokenKind;
use pion_utils::location::{TokenPos, TokenSpan};

use bumpalo::Bump;

use crate::syntax::*;
use crate::reporting::SyntaxError;

grammar<'surface>(
    bump: &'surface Bump,
    errors: &mut Vec<SyntaxError>,
);

extern {
    type Location = TokenPos;
    type Error = std::convert::Infallible;

    enum TokenKind {
        "Ident" => TokenKind::Ident,
        "DecInt" => TokenKind::DecInt,
        "BinInt" => TokenKind::BinInt,
        "HexInt" => TokenKind::HexInt,

        "def" => TokenKind::KwDef,
        "else" => TokenKind::KwElse,
        "false" => TokenKind::KwFalse,
        "fun" => TokenKind::KwFun,
        "if" => TokenKind::KwIf,
        "let" => TokenKind::KwLet,
        "match" => TokenKind::KwMatch,
        "then" => TokenKind::KwThen,
        "true" => TokenKind::KwTrue,

        "(" => TokenKind::LParen,
        ")" => TokenKind::RParen,
        "{" => TokenKind::LCurly,
        "}" => TokenKind::RCurly,
        "[" => TokenKind::LSquare,
        "]" => TokenKind::RSquare,
        "_" => TokenKind::Underscore,
        "," => TokenKind::Comma,
        ";" => TokenKind::Semicolon,
        ":" => TokenKind::Colon,
        "." => TokenKind::Dot,
        "@" => TokenKind::At,
        "=" => TokenKind::Eq,
        "->" => TokenKind::ThinArrow,
        "=>" => TokenKind::FatArrow,
    }
}


// ==== Items ====
pub Module: Module<'surface> = {
    <items: Item*> => Module {items: bump.alloc_slice_copy(&items)},
}

pub Item: Item<'surface> = {
    <start: @L> <error: !> <end: @R> => { errors.push(SyntaxError::from_recovery(error)); Item::Error(TokenSpan::new(start, end)) },
    Def => Item::Def(<>),
}

Def: Def<'surface> = {
    <start: @L> "def" <name: Ident> "=" <expr: Expr> ";" <end: @R> => Def{span: TokenSpan::new(start, end), name, r#type: None, expr},
    <start: @L> "def" <name: Ident> ":" <r#type: Expr> "=" <expr: Expr> ";" <end: @R> => Def{span: TokenSpan::new(start, end), name, r#type: Some(r#type), expr},
}

// ==== Expressions ====

pub Expr: Expr<'surface> = {
    LetExpr => <>,
}

LetExpr: Expr<'surface> = {
    <start: @L> "let" <pat: Pat> <r#type: (":" <Expr>)?> "=" <init: Expr> ";" <body: Expr> <end: @R> => Expr::Let(TokenSpan::new(start, end), bump.alloc((pat, r#type, init, body))),
    <start: @L> "if" <scrut: Expr> "then" <then: Expr> "else" <r#else: Expr> <end: @R> => Expr::If(TokenSpan::new(start, end), bump.alloc((scrut, then, r#else))),
    FunExpr => <>,
}

FunExpr: Expr<'surface> = {
    <start: @L> "fun" "(" <params: Seq<FunParam, ",">> ")" "=>" <body: Expr> <end: @R> => Expr::FunLit(TokenSpan::new(start, end), params, bump.alloc(body)),
    <start: @L> "fun" "(" <params: Seq<FunParam, ",">> ")" "->" <body: Expr> <end: @R> => Expr::FunType(TokenSpan::new(start, end), params, bump.alloc(body)),
    <start: @L> <param: ProjExpr> "->" <body: Expr> <end: @R> => Expr::FunArrow(TokenSpan::new(start, end), bump.alloc((param, body))),
    ProjExpr => <>,
}

ProjExpr: Expr<'surface> = {
    <start: @L> <head: ProjExpr> "." <name: Ident> <end: @R> => Expr::FieldProj(TokenSpan::new(start, end), bump.alloc(head), name),
    CallExpr => <>,
}

CallExpr: Expr<'surface> = {
    <start: @L> <fun: CallExpr> "(" <args: Seq<FunArg, ",">> ")" <end: @R> => Expr::FunCall(TokenSpan::new(start, end), bump.alloc(fun), args),
    <start: @L> <head: ProjExpr> "." <method: Ident> "(" <args: Seq<FunArg, ",">> ")" <end: @R> => Expr::MethodCall(TokenSpan::new(start, end), bump.alloc(head), method, args),
    AtomExpr => <>,
}

AtomExpr: Expr<'surface> = {
    <start: @L> <error: !> <end: @R> => { errors.push(SyntaxError::from_recovery(error)); Expr::Error(TokenSpan::new(start, end)) },

    <lit: Lit> => Expr::Lit(lit),
    <underscore: Underscore> => Expr::Underscore(underscore),
    <ident: Ident> => Expr::Ident(ident),

    <start: @L> "(" <expr: ProjExpr> ":" <r#type: FunExpr> ")" <end: @R> => Expr::Ann(TokenSpan::new(start, end), bump.alloc((expr, r#type))),
    <start: @L> "(" <expr: Expr> ")" <end: @R> => Expr::Paren(TokenSpan::new(start, end), bump.alloc(expr)),
    <start: @L> <exprs: Tuple<Expr>> <end: @R> => Expr::TupleLit(TokenSpan::new(start, end), exprs),
    <start: @L> "[" <exprs: Seq<Expr, ",">> "]" <end: @R> => Expr::ArrayLit(TokenSpan::new(start, end), exprs),
    <start: @L> "match" <scrut: Expr> "{" <cases: Seq<MatchCase, ",">> "}" <end: @R> => Expr::Match(TokenSpan::new(start, end), bump.alloc(scrut), cases),
    <start: @L> "{" "}" <end: @R> => Expr::TupleLit(TokenSpan::new(start, end), &[]),
    <start: @L> "{" <fields: Seq1<ExprField, ",">> "}" <end: @R> => Expr::RecordLit(TokenSpan::new(start, end), fields),
    <start: @L> "{" <fields: Seq1<TypeField, ",">> "}" <end: @R> => Expr::RecordType(TokenSpan::new(start, end), fields),
}

FunArg: FunArg<'surface> = {
    <start: @L> <plicity: Plicity> <expr: Expr> <end: @R> => FunArg {span: TokenSpan::new(start, end), plicity, expr},
}

FunParam: FunParam<'surface> = {
    <start: @L> <plicity: Plicity> <pat: Pat> <r#type: (":" <Expr>)?> <end: @R> => FunParam {span: TokenSpan::new(start, end), plicity, pat, r#type},
}

Plicity: Plicity = {
    () =>  Plicity::Explicit,
    <pos: @L> "@" => Plicity::Implicit(pos),
}

MatchCase: MatchCase<'surface> = {
    <start: @L> <pat: Pat> <guard: ("if" <Expr>)?> <end: @R> "=>" <expr: Expr> => MatchCase {span: TokenSpan::new(start, end), pat, guard, expr},
}

ExprField: ExprField<'surface> = {
    <start: @L> <name: Ident> <expr: ("=" <Expr>)?> <end: @R> => ExprField {span: TokenSpan::new(start, end), name, expr},
}

TypeField: TypeField<'surface> = {
    <start: @L> <name: Ident> ":" <r#type: Expr> <end: @R> => TypeField {span: TokenSpan::new(start, end), name, r#type},
}

// ==== Patterns ====

pub Pat: Pat<'surface> = {
    AtomPat => <>,
}

AtomPat: Pat<'surface> = {
    <start: @L> <error: !> <end: @R> => { errors.push(SyntaxError::from_recovery(error)); Pat::Error(TokenSpan::new(start, end)) },
    <lit: Lit> => Pat::Lit(lit),
    <underscore: Underscore> => Pat::Underscore(underscore),
    <ident: Ident> => Pat::Ident(ident),

    <start: @L> "(" <pat: Pat> ")" <end: @R> => Pat::Paren(TokenSpan::new(start, end), bump.alloc(pat)),
    <start: @L> <pats: Tuple<Pat>> <end: @R> => Pat::TupleLit(TokenSpan::new(start, end), pats),
    <start: @L> "{" <fields: Seq<PatField, ",">> "}" <end: @R> => Pat::RecordLit(TokenSpan::new(start, end), fields),
}

PatField: PatField<'surface> = {
    <start: @L> <name: Ident> <pat: ("=" <Pat>)?> <end: @R>  => PatField { span: TokenSpan::new(start, end), name, pat },
}

// ==== Literals ====

Lit: Lit = {
    BoolLit => Lit::Bool(<>),
    IntLit => Lit::Int(<>),
}

BoolLit: BoolLit = {
    <pos: @L> "true"  => BoolLit::True(pos),
    <pos: @L> "false" => BoolLit::False(pos),
}

IntLit: IntLit = {
    <pos: @L> "DecInt" => IntLit::Dec(pos),
    <pos: @L> "BinInt" => IntLit::Bin(pos),
    <pos: @L> "HexInt" => IntLit::Hex(pos),
}

// ==== Names ====

Ident: Ident = {
    <pos: @L> "Ident" => {
        Ident { pos }
    }
}

// ==== Underscores ====

Underscore: Underscore = {
    <pos: @L> "_" => {
        Underscore { pos }
    }
}

// ==== Generic parsers ====

Tuple<Elem>: &'surface [Elem] = {
    "(" ")" => &[],
    "(" <elem: Elem> "," ")" => std::slice::from_ref(bump.alloc(elem)),
    "(" <elems: Seq2<Elem, ",">> ")" => elems,
};

// ==== Generic helpers ====

Seq<Elem, Sep>: &'surface [Elem] = {
    <elems: (<Elem> Sep)*> <last: Elem?> => {
        let len = elems.len() + last.is_some() as usize;
        let mut iter = elems.into_iter().chain(last);
        bump.alloc_slice_fill_with(len, |_| iter.next().unwrap())
    }
};

Seq1<Elem, Sep>: &'surface [Elem] = {
    <first: Elem> <elems: (Sep <Elem>)*> Sep? => {
        let len = elems.len() + 1;
        let mut iter = std::iter::once(first).chain(elems);
        bump.alloc_slice_fill_with(len, |_| iter.next().unwrap())
    },
};

Seq2<Elem, Sep>: &'surface [Elem] = {
    <first: Elem> Sep <second: Elem> <elems: (Sep <Elem>)*> Sep? => {
        let len = elems.len() + 2;
        let mut iter = std::iter::once(first).chain(std::iter::once(second)).chain(elems);
        bump.alloc_slice_fill_with(len, |_| iter.next().unwrap())
    },
};
