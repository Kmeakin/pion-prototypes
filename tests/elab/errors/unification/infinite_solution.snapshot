exit status: 1

stdout = """
def error: fun(Wrap: Type -> Type) -> (fun(A: Type) -> (A -> Wrap(A)) -> Type) -> Type = fun(Wrap: Type -> Type, f: fun(A: Type) -> (A -> Wrap(A)) -> Type) => f(?3(FIXME_PRETTY_INSERTED_META, FIXME_PRETTY_INSERTED_META), fun(a: ?3(Wrap, f)) => #error);
types of expressions:
11..89 = Type
21..25 = Type
21..33 = Type
29..33 = Type
38..89 = Type
45..80 = Type
52..53 = Type
58..72 = Type
58..80 = Type
59..60 = Type
64..68 = Type -> Type
64..71 = Type
69..70 = Type
76..80 = Type
85..89 = Type
94..134 = fun(Wrap: Type -> Type) -> (fun(A: Type) -> (A -> Wrap(A)) -> Type) -> Type
107..134 = (fun(A: Type) -> (A -> Wrap(A)) -> Type) -> Type
117..118 = fun(A: Type) -> (A -> Wrap(A)) -> Type
117..134 = Type
119..120 = Type
122..133 = (?3(Wrap, f)) -> Wrap(?3(Wrap, f))
132..133 = Wrap(?3(Wrap, f))
types of patterns:
15..19 = Type -> Type
42..43 = fun(A: Type) -> (A -> Wrap(A)) -> Type
49..50 = ?1(Wrap)
98..102 = Type -> Type
111..112 = fun(A: Type) -> (A -> Wrap(A)) -> Type
126..127 = ?3(Wrap, f)
metavars:
?0 = fun(_: #error) => Type
?1 = fun(_: #error) => Type
?2 = fun(_: #error, _: #error) => Type
?3 = <unsolved>
"""

stderr = """
error: infinite solution
  ┌─ tests/elab/errors/unification/infinite_solution.pion:2:43
  │
2 │   = fun(Wrap) => fun(f) => f(_, fun(a) => a);
  │                                           ^

error: unable to infer expression to solve hole
  ┌─ tests/elab/errors/unification/infinite_solution.pion:2:30
  │
2 │   = fun(Wrap) => fun(f) => f(_, fun(a) => a);
  │                              ^

aborting due to 2 previous errors
"""
