// Eq:    fun(@A: Type, x: A, y: A) -> Type
// refl:  fun(@A: Type, x: A) -> Eq(@A, x, x)
// subst: fun(@A: Type, @x: A, @y: A, @p: A -> Type, x_eq_y: Eq(@A, x, y), p_x: p(x)) -> p(y)

def sym: fun(@A: Type, a: A, b: A) -> Eq(a, b) -> Eq(b, a)
       = fun(a, b, a_eq_b)
         =>
            let p = fun(x) => Eq(@A, x, a);
            let p_a:  p(a) = refl(a);
            let goal: p(b) = subst(@A, @a, @b, @p, a_eq_b, p_a);
            goal
            ;

def trans: fun(@A: Type, a: A, b: A, c: A) -> Eq(a, b) -> Eq(b, c) -> Eq(a, c)
         = fun(a, b, c, a_eq_b, b_eq_c)
          =>
            let p = fun(x) => Eq(@A, a, x);
            let p_b: p(b) = a_eq_b;
            let goal: p(c) = subst(@A, @b, @c, @p, b_eq_c, p_b);
            goal
            ;

def cong: fun(@A: Type, @B: Type, a: A, b: A, f: A -> B) -> Eq(a, b) -> Eq(f(a), f(b))
         = fun(a, b, f, a_eq_b)
          =>
            let p = fun(x) => Eq(@B, f(a), f(x));
            let p_a:  p(a) = refl(f(a));
            let goal: p(b) = subst(@A, @a, @b, @p, a_eq_b, p_a);
            goal
            ;
