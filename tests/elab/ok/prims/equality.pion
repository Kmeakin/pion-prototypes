// Eq:    fun(@A: Type, x: A, y: A) -> Type
// refl:  fun(@A: Type, x: A) -> Eq(@A, x, x)
// subst: fun(@A: Type, @x: A, @y: A, @p: A -> Type, x_eq_y: Eq(@A, x, y), p_x: p(x)) -> p(y)

def sym: fun(@A: Type, a: A, b: A) -> Eq(a, b) -> Eq(b, a)
    = fun(a, b, a_eq_b) =>
        let p = fun(x) => Eq(@A, x, a);
        let p_a:  p(a) = refl(a);
        let goal: p(b) = subst(@A, @a, @b, @p, a_eq_b, p_a);
        goal
        ;

def trans: fun(@A: Type, a: A, b: A, c: A) -> Eq(a, b) -> Eq(b, c) -> Eq(a, c)
    = fun(a, b, c, a_eq_b, b_eq_c) =>
        let p = fun(x) => Eq(@A, a, x);
        let p_b: p(b) = a_eq_b;
        let goal: p(c) = subst(@A, @b, @c, @p, b_eq_c, p_b);
        goal
        ;

def cong: fun(@A: Type, @B: Type, a: A, b: A, f: A -> B) -> Eq(a, b) -> Eq(f(a), f(b))
    = fun(a, b, f, a_eq_b) =>
        let p = fun(x) => Eq(@B, f(a), f(x));
        let p_a:  p(a) = refl(f(a));
        let goal: p(b) = subst(@A, @a, @b, @p, a_eq_b, p_a);
        goal
        ;

def cong-app: fun(@A: Type, @B: Type, a: A, f: A -> B, g: A -> B) -> Eq(f, g) -> Eq(f(a), g(a))
    = fun(a, f, g, f_eq_g) =>
        let p = fun(x : A -> B) => Eq(@B, f(a), x(a));
        let p_f: p(f) = refl(_);
        let goal = subst(@(A -> B), @f, @g, @p, f_eq_g, p_f);
        goal
        ;

def not: Bool -> Bool
    = fun(x) => match x {
        true => false,
        false => true,
    };

def not_false_eq_true: Eq(not(false), true) = refl(_);
def not_true_eq_false: Eq(not(true), false) = refl(_);

def not_self_inverse: fun(b: Bool) -> Eq(not(not(b)), b)
    = fun(b) =>
        let p = fun(a) => Eq(not(not(a)), a);
        let p_true = refl(_);
        let p_false = refl(_);
        bool_rec(b, p, p_true, p_false)
        ;
